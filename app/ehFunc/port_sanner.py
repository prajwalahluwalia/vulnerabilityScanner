import socket
from IPy import IP
import logging
from datetime import datetime
import time

logging.basicConfig(filename='logFile.log', encoding='utf-8', level=logging.DEBUG)

class PortScanner:
    def __init__(self, targets, port_start, port_end):
        self.targets = targets
        self.port_start = port_start
        self.port_end = port_end
        self.banner = []

    def get_port_details(self):
        targets = self.targets.split(',')
        hm = {}
        for target in targets:
            res = []
            start = time.time()
            val = self.scan(target.strip())
            if val:
                res.append(val)
                hm[target]=res[0]
            else:
                hm[target]=res
            
            print(time.time()-start)
        return hm
    
    # scan functions by passing target as a param. checks ip target has corect IP address format. After that we pass fetched correct IP in port_numbers provides default port_start will be 1.
    def scan(self, target):
        res = []
        ip = self.check_ip(target)
        print('Scanning target... '+ str(target))
        for port in range(self.port_start, self.port_end):
            val = self.scan_port(ip, port)
            if val:
                res.append(val[0])
        return res
    
    # checks if target ip is in correct ip address format and returns IP back
    def check_ip(self, ip):
        try:
            IP(ip)
            return ip
        
        except ValueError as e:
            logging.error(f'[+{datetime.now()} port_scanner]: {e}')
            return socket.gethostbyname(ip)
        
    #grabs banner by receiving data from open ports to let us know service is running in open ports and not more than 1024 bytes is required to grab the banner
    def get_banner(self, s):
        # logging.info(f'[+{datetime.now()} port_scanner]: {s.recv(1024)}')
        return s.recv(1024)
    
    '''
    params - ip and port
    - establishes connection with target by sending requests to all requested ports
    - analyze resp and prints open ports with banners or print open ports where failed to find any banners
    - timeout set to 0.5 to spped up scan process. accuracy of scan depends on timeout set and directly proportional i.e. lower timeout = lower accuracy 
    '''
    def scan_port(self, ip, port):
        res = []
        try:
            sock = socket.socket()
            sock.settimeout(0.5)
            sock.connect((ip, port))
            val = 'No Banner found.'
            try:
                banner = self.get_banner(sock)
                val = str(banner.decode().strip('\n').strip('\n'))
                self.banner.append(val)
                print("[+] Open port: ",str(port), "-", val)
                logging.info(f'[+{datetime.now()} port_scanner]: Open port: {str(port)}-{val}')
            except:
                logging.info(f'[+{datetime.now()} port_scanner]: Open port: {str(port)}-{val}')
            
            res.append([str(port), val])
            
        except Exception as e:
            # print(f'for port:{port} and ip:{ip}-{e}')
            logging.error(f'[+ {datetime.now()} port_scanner for port:{port} and ip:{ip} ]: {str(e)}')
        
        return res